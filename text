01_2_Hello_World (워터마크 있음)

프로그램:		컴퓨터에게 수행하게 하려는 작업
소스코드:		*.cpp, *.h와 같이 프로그래머가 작성한 텍스트파일
목적코드:		소스코드를 *.obj, *.o와 같이 해당 컴퓨터에 맞게 변환 한 것
컴파일:			소스코드를 목적코드로 바꾸는 과정
링크:			목적어들을 모두 연결하여 실행파일을 만들어 주는 과정
빌드:			IDE에서 컴파일과 링크를 합쳐서 부르는 말
라이브러리:		다른 사람이 작성한 코드로, 프로그래밍을 쉽게 도와주는 프로그램의 집합
IDE:			VisualStudio, XCode등과 같은 프로그램, 편집기+컴파일러+링커의 도구 집합
함수:			여러개의 명령어를 가지고 있는 집합에 이름을 붙인 것. 반환 타입, 이름, 매개변수 목록, 본체 등의 요소를 가지고 있다.
에러:			컴퓨터 처리 시에 예상하지 못한 결과 또는 원하는 적절한 결과를 얻지 못하여 발생한 경우
main():			모든 프로그램이 가지고 있으며, 모든 프로그램의 시작지점 = Entry Point
솔루션:			*.sln과 같이 관련있는 여러 개의 프로젝트를 모아 한 번에 관리하는 파일 구조
프로젝트:		*.vcxproj와 같이 비주얼스튜디오에서 앱을 빌드 하기 위해 필요한 모든 아이템(소스코드, 아이콘, 이미지 등)을 모아둔 것

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_1_객체_타입_값 (워터마크 있음)

ASCII:			미국정보교환표준부호(American Standard Code for Information Interchange)로 영문 알파벳을 사용하는 문자 인코딩
std::cout:		문자 출력 스트림
std::cin:		문자 입력 스트림
변수:			[객체에 이름을 붙여둔 것] / 값을 직접 집어넣고 꺼내는데 사용하는 객체
int:			4바이트 크기의 정수 타입
float:			4바이트 크기의 소수 타입
bool:			1바이트 크기의 참 거짓(1과 0)
char:			1바이트 크기의 문자 타입
overflow:		허용할 수 있는 값 이상으로 값을 증가시켰을 때 가장 작은 값으로 바뀌어 버리는 것
underflow:		허용할 수 있는 값 이하로 값을 감소시켰을 때 가장 큰 값으로 바뀌어 버리는 것
선언:			컴파일러가 참조할 식별자와 이름을 알리는 것. 중복되어도 문제없으며 두 번 이상 할 수 있음[객체의이름을 지정하는 구문]
정의:			식별자와 이름으로부터 코드를 생성하는 것. 프로그램에는 정의가 하나만 있어야 함[객체의 메모리 공간을 할당하는 일종의 선언]
초기화:			데이터 오브젝트나 변수의 초기 값 할당을 의미함
배정문:			프로그램에서 사용하는 여러 종류의 값들을 기억장소에 저장하기 위해 사용
Camel 표기법:		소문자로 시작하고 단어가 바뀌면 첫글자를 대문자로 표기
유니폼 초기화:		중괄호를 이용한 초기화..
lvalue:			연산자 좌측의 피연산자로 어떠한 이름을 가진 객체
rvalue:			연산자 우측의 피연산자로 어떠한 숫자의 값

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_2_리터럴과_연산자 (워터마크 있음)

리터럴:			쓰여진 값 그대로 사용되는 값. 변수가 아닌 숫자들
Escape Sequence: 	흐름을 벗어난다. 즉 일반적인 문자 표기법과 다른 형태를 가진 특수기호
산술 연산자:		정수 및 실수와 함께 사용될 때 사칙 연산을 수행하는 연산자
비트 연산자:		2진법(비트)에 대한 산술 연산(비트연산)을 수행하는 연산자
배정 연산자:		값을 때입한다는 의미로 사용되는 연산자. 일반 수항게서는 값의 같음을 비교하는데 사용하지만 쓰임처가 다르다.
증감 연산자:		변수의 앞 혹은 뒤에 사용하며 변수의 증가와 감소를 나타낸다. 배정문과 함께 사용할때 단일표현식이 앞 뒤냐에 따라 결과가 달라짐.
비교 연산자:		두 변수의 관계를 확인하는 연산자. 관계 연산자라고도 부름. 결과는 불린값이다
논리 연산자:		논리식을 판단하여 참 거짓을 반환하는 연산자

-----------------------------------------------------------------------------------------------------------------------------------------------------

02_3_컴퓨터개론 (워터마크 있음)

-2진수 변환-
15 => 1111(2)
127 => 1111111(2)
255 => 11111111(2)

-16진수 변환-
15 => F(0x)
127 => 7F(0x)
255 => FF(0x)

-----------------------------------------------------------------------------------------------------------------------------------------------------

03_1_구문과_흐름제어_1 (워터마크 있음)

인자:			키보드, 마우스등의 기본 입력 or 터치 스크린, 다른 프로그램, 프로그램 내부의 데이터 등의 다양한 입력들
자료구조:		입력을 처리하기 위해 필요한 다양한 데이터들을 묶어서 관리하는 것
표현식:			간단하게 식이라고도 부르며 하나 이상의 값으로 표현될 수 있는 코드
Lexicon:		어휘, 프로그램에서 문자로 쓰이는 것들
Syntax:			구문, 어휘의 조합..표현에 어울리는 구성
Semantic:		의미, 구문에서 만들어낸 맥락..? semantic error는 logical error라고도 한다. 프로그래머의 실수를 말함
if 구문:		조건식의 참과 거짓을 판별하여 ..
Flow Chart:		순서도라고도 하며 선택구문의 조건식에 의한 흐름을 도식화 한것
전치리기 지시문:	#include와 같이 컴파일 과정에서 가장 먼저 변환되어지며 <>안의 내용을 전부 가져와서 1번 라인에 포함시켜버리며 가장 앞에 #이 붙어있음
switch ~ case 구문: 	조건식의 참 거짓 여부를 판단하여 분기하는 if구문과 다르게 값에 의해 분기하는 구문
레이블(Label):		소스 코드 안의 위치를 식별하는 일련의 문자열. ex) setich~case 구문에서 case등

-----------------------------------------------------------------------------------------------------------------------------------------------------

03_2_구문과_흐름제어_2 (워터마크 있음)

while 구문:		do ~while 구문과 비슷하지만 블럭 안의 내용이 무조건 한번은 실행하고 조건을 판단하는 do ~ while과 다르게 while문은 조건식 판단을 먼저 하고 반복한다.
do ~ while 구문:	조건식이 true일 동안에 표현식을 반복 수행하는 구문. 반복해서 증가하는 변수의 선언은 do {}블록 밖에 있다는 것에 주의.
for 구문:		초기화를 수행한 후 조건식을 비교하는 반복문. 초기화 / 연산으로 이뤄진 반복문은 while보다 더 유용하다
Local 변수:		중괄호 안에서 사용된 변수로, 지역 변수는 해당 중괄호 블록에서만 사용할 수 있게 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------

04_2_배열 (워터마크 있음)

암시적 변환:		정보 손실의 최소화 원칙에 따라 컴파일러가 타입을 자동적으로 변환 하는것. 표현 범위가 좁은 데이터 타입에서 -> 넓은 데이터 타입으로의 변환만 허용된다.
명시적 변환:		사용자가 직접 데이터의 타입을 변경하는 것. ()를 이용하여 묵시적 형변환과 다르게 표현 범위가 넓은 데이터 타입에서 좁은 데이터 타입으로의 변환 허용. 단! 데이터 값이 손실될 수 있다.
타입안정성:		타입의 규칙에 따라 객체를 이용하는것
축소변환:		저장공간이 큰 것을 작은 것으로 변환하는것. 값이 잘려나가며 프로그램에서 알수 없는 에러의 주범이 되기도함. ex)int(4 byte)->char(1 byte)
오버플로:    		데이터를 집어 넣을 때 준비 된 공간을 넘어가 버리는 일
열거형:			유한한 집합을 표현하기 위한 형식
구조체:			
배열:			동일한 형식의 값을 여러 개 저장할 경우에 사용할 수 있는 개념
문자열:
왼쪽값:			변수와 같은 저장할 수 있는 개체들. 한줄의 코드를 넘어 지속되는 특징을 가졌다. lvalue가 rvalue에 대입은 되지않는다.
오른쪽값:		리터럴, 상수, 연산식과 같이 현재 식 이외에는 유지되지 않는 임시 값들. rvalue를 lvalue에 대입 가능하다.

-----------------------------------------------------------------------------------------------------------------------------------------------------

05_2_재귀함수 (워터마크 있음)

함수 선언:		미리 어떤 함수가 있는지 알려주는 것. 함수 원형이라고도 한다. 위쪽에 선언한다.
함수 정의:		실제로 함수가 어떤 연산을 하는지 작성하는 곳. 
매개변수:		함수 정의에 열거된 이름(Callee)	
인자:			함수 호출에 넘겨줄 값(Caller)
값에 의한 호출:		함수를 홀출할 때 인자의 값이 매개변수로 복사되어 넘어가는 일.
함수 다형성:		매개변수 일치를 이용해서 함수가 다양한 형태를 가진것
지역 변수:		{} 블록 안에서 정의된 변수. 블록을 넘어가면 소멸된다.
전역 변수:		지역변수와 반대로 소스파일 어디에서도 사용할 수 있는 변수.
변수 범위:			
함수 오버로딩:		반환값과 이름이 같은 함수 
함수 시그니쳐:		함수의 이름, 매개변수의 타입, 개수, 순서등 함수의 특성을 나타내는 고유값
프로그램 진입점:	프로그램이 실행될 때 자동적으로 호출하는 main()함수. return을 명시하지 않아도 자동적으로 0을 반환하며 프로그램을 종료합니다.
재귀 함수:		함수 내부에서 자기 자신을 다시 호추랗는 함수.
스택:			새로 호출되는 것을 쌓고 반환하면 마지막에 저장된 것을 꺼내는 자료구조

-----------------------------------------------------------------------------------------------------------------------------------------------------

06_3_동적메모리관리 (워터마크 있음)

포인터(pointer):
참조에 의한 호출(call by value):
포인터 변수의 크기(size of pointer):
화살표 연산자(Arrow Operator):
참조형(Reference Type): 
참조형은 C가 아닌 C++에서 업그레이드 된 포인터의 형태
	-참조형은 선언하는 동시에 반드시 초기화 해야한다.
	-초기화 이후에는 다른 변수를 가리킬 수 없다.
	--참조형은 매개변수로 많이 사용된다.
참조형은 기본적으로 const 포인터이기 때문에 가리키는 대상을 바꿀 수 없다.

동적 메모리 할당(Dynamic Memory Allocation):  프로그래머가 필요할 때 만들고 제거할 수 있는 형태. 포인터의 핵심 기능
함수 포인터(Function Pointer):

-----------------------------------------------------------------------------------------------------------------------------------------------------

07_1_오류 (워터마크 있음)

예외: 			예상 밖의 인자, 예상 밖의 입력, 잘못 된 계산
컴파일시간 오류: 	컴파일러가 찾아낸 오류로 가장 수정하기 쉬운 것(문법 오류, 타입 오류 등)
실행시간 오류: 		프로그램을 실행하는 동안 발생하는 오류로, 용의주도하고 꼼꼼한 프로그래머라면 그나마 수정하기 쉬움(컴퓨터,라이브러리,사용자 등이 감지한 오류)
링크시간 오류: 		링커가 탐지한 오류로 역시 수정하기 쉽다. 주로 외부 라이브러리의 잘못된 사용으로 발생
exception: 		오류에 대한 처리를 지원하는 기능(오류 발생, 예외 탐지 및 처리)
throw: 			함수가 처리할 수 없는 오류가 발생하면 일반적인 return이 아닌 예외를 던짐
try: 			함수를 직간접적으로 호출한 모든 쪽에서 계산을 시도함
catch: 			예외를 잡아내서 해당 예외에 대한 처리를 수행하기
디버깅:

비주얼스튜디오 디버깅
중단점(F9)
프로시저 단위 실행(F10)
한 단계씩 코드 실행(F11)
:

-----------------------------------------------------------------------------------------------------------------------------------------------------

08_1_알고리즘훈련 (워터마크 있음)

시간 복잡도(Time Complexity): 	알고리즘의 시작 ~ 끝 까지 소요되는 시간을 분석. 시간을 측정하는 것은 컴퓨터에 따라 다를 수 있기 때문에 수행 횟수를 산출합니다.
공간 복잡도(Space Complexity): 	알고리즘의 연산 도중에 사용되는 메모리를 분석. 바이트 단위로 측정하지 않고 주로 일반적인 단위(변수)로 산출합니다.
빅 오(Big O): 			알고리즘의 효율성을 표기해주는 표기법. 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는데 주로 사용한다.
O(n^2): 			빅 오 패턴중 다항식 형태로 증가하는 알고리즘. n^c 형태로 n은 입력의 크기, c는 상수를 나타낸다. 정렬과 같이 원소를 나머지 원소와 비교하는 형태에서 자주 등장한다.
O(n log n): 			빅 오 패턴중 선형 연산이 로그식에 중첩되어 있는 형태. O(n) 보다는 느리지만 O(n^2) 보다는 빠른 형태로 느린 코드를 최적화 하다보면 자주 등장하는 패턴이다.
선택 정렬(Selection Sort): 	가장 쉬운 알고리즘. 현재 i번째 이후의 가장 작은 값을 찾아서 가장 앞으로 보내는 방식. 가장 작거나 큰값을 선택하는 방식이라 선택 정렬이라고 부른다. 시간 복잡도 O(n^2), 공간 복잡도 O(n).
삽입 정렬(Insertion Sort): 	앞에서 부터 차례로 진행하면서 자신이 위치해야 할 곳에 값을 삽입하는 방식입니다. 교환이 아니라 자신의 위치에 값을 삽입해야 하므로 그 앞의 모든 배열을 조작해야 합니다. 시간 복잡도 O(n^2), 공간 복잡도 O(n).
거품 정렬(Bubble Sort): 	인접한 두개의 원소를 검사하여 큰 값을 뒤로 보내는 과정을 반복하는 정렬이다. 인접한 두 개의 값을 비교하는 특성이 거품이 떠오르는 것 같다고 해서 붙여진 이름이다. 시간 복잡도 O(n^2), 공간 복잡도 O(n).
합병 정렬(Merge Sort): 		분할 정복 알고리즘을 사용한 정렬이다. 주어진 입력으로 바로 문제를 풀기 어려울 때, 이를 작은 문제로 분할하여 해결하는 방식이다. 분할되어 있는 행렬을 합해서 임시 공간에 저장하고 함수에 넘겨주는 방식을 사용한다. 시간 복잡도 O(n log n), 공간 복잡도 O(n).
퀵 정렬(Quick Sort): 		가장 많이 사용되는 빠른 알고리즘이다. 역시 분할 정복을 사용한다. 배열의 특정 원소를 피벗값으로 지정 후 피벗보다 작은 값을 왼쪽, 큰 값을 오른쪽으로 정렬한다. 피벗 기준으로 리스트를 좌/우로 분할하며 위 과정을 반복한다. 시간 복잡도 O(n log n), 공간 복잡도 O(n).


-----------------------------------------------------------------------------------------------------------------------------------------------------

09_1_자료구조 (워터마크 있음)

자료 구조(Data Structure): 			컴퓨터를 이루는 입력, 계산, 출력 중 입력/출력을 효율적으로 관리하는 방법.
동적 자료 구조(Dynamic Data Structure): 	동적으로 자료를 생성하고 관리하는 것
자기 참고 구조체(Self Referenced Structure): 	구조체가 멤버로 자신의 구조체를 가리키는 포인터를 가지는 것. 동일한 구조체가 하나 더 필요할 때 복사하는 과정 없이 상수 타임에 관리할 수 있다.
단일 연결 리스트(Linked List): 			일렬로 나열된 동적 자료구조. 각 원소는 다음 원소를 가르키는 포인터를 가지고 있다.
이중 연결 리스트(Double Linked List): 		단일 연결 리스트와 달리 자신의 앞/뒤를 가르키는 포인터를 모두 가지고 있는 리스트. 정방향/역방향 모두 쉽게 탐색이 가능하며 특정한 위치의 원소를 삭제하기 편하다.
